package speiger.src.collections.PACKAGE.lists;

import java.util.List;
#if !TYPE_OBJECT && !TYPE_BOOLEAN
import java.util.Objects;
import java.util.function.UNARY_OPERATOR;
import java.util.function.UnaryOperator;
#endif
import java.util.Comparator;

import speiger.src.collections.PACKAGE.collections.COLLECTION;
#if !TYPE_OBJECT
import speiger.src.collections.PACKAGE.functions.COMPARATOR;
#endif
import speiger.src.collections.PACKAGE.utils.ARRAYS;
#if TYPE_BYTE || TYPE_SHORT || TYPE_CHAR || TYPE_FLOAT
import speiger.src.collections.utils.SanityChecks;
#endif

public interface LIST KEY_GENERIC_TYPE extends COLLECTION KEY_GENERIC_TYPE, List<CLASS_TYPE>
{
#if !TYPE_OBJECT
	@Override
	public boolean add(KEY_TYPE e);
	
	public void add(int index, KEY_TYPE e);
	
#endif
	public boolean addAll(int index, COLLECTION KEY_GENERIC_TYPE c);
	
	public boolean addAll(LIST KEY_GENERIC_TYPE c);
	
	public boolean addAll(int index, LIST KEY_GENERIC_TYPE c);
	
#if !TYPE_OBJECT
	public KEY_TYPE GET_KEY(int index);
	
	public KEY_TYPE set(int index, KEY_TYPE e);
	
	public KEY_TYPE REMOVE(int index);
	
	public int indexOf(KEY_TYPE e);
	
	public int lastIndexOf(KEY_TYPE e);

#if !TYPE_BOOLEAN
	public default void REPLACE(UNARY_OPERATOR o) {
        Objects.requireNonNull(o);
        LIST_ITERATOR iter = listIterator();
        while (iter.hasNext())
#if TYPE_BYTE || TYPE_SHORT || TYPE_CHAR || TYPE_FLOAT
        	iter.set(SanityChecks.SANITY_CAST(o.APPLY(iter.NEXT())));
#else
			iter.set(o.APPLY(iter.NEXT()));
#endif
	}
	
#endif
#endif
	public default void addElements(int from, KEY_TYPE[] a) { addElements(from, a, 0, a.length); }
	
	public void addElements(int from, KEY_TYPE[] a, int offset, int length);
	
	public default KEY_TYPE[] getElements(int from, KEY_TYPE[] a) { return getElements(from, a, 0, a.length); }
	
	public KEY_TYPE[] getElements(int from, KEY_TYPE[] a, int offset, int length);
	
	public void removeElements(int from, int to);
	
#if TYPE_OBJECT
	public KEY_TYPE[] extractElements(int from, int to, Class<KEY_TYPE> type);
	
	@Override
	public default void sort(Comparator<? super CLASS_TYPE> c) {
		KEY_TYPE[] array = (KEY_TYPE[])TO_ARRAY();
		if(c != null) ARRAYS.stableSort(array, c);
		else ARRAYS.stableSort((Comparable[])array);
    	LIST_ITERATOR KEY_GENERIC_TYPE iter = listIterator();
    	for (int i = 0,m=size();i<m && iter.hasNext();i++) {
    		iter.NEXT();
    		iter.set(array[i]);
    	}
	}
	
	public default void unstableSort(Comparator<? super CLASS_TYPE> c) {
		KEY_TYPE[] array = (KEY_TYPE[])TO_ARRAY();
		if(c != null) ARRAYS.unstableSort(array, c);
		else ARRAYS.unstableSort((Comparable[])array);
        LIST_ITERATOR KEY_GENERIC_TYPE iter = listIterator();
        for (int i = 0,m=size();i<m && iter.hasNext();i++) {
        	iter.NEXT();
        	iter.set(array[i]);
        }
	}
	
#else
	public KEY_TYPE[] extractElements(int from, int to);
	
	@Override
	default void sort(Comparator<? super CLASS_TYPE> c) {
		sort((K, V) -> c.compare(KEY_TO_OBJ(K), KEY_TO_OBJ(V)));
	}

	public default void sort(COMPARATOR c) {
		KEY_TYPE[] array = TO_ARRAY();
		if(c != null) ARRAYS.stableSort(array, c);
		else ARRAYS.stableSort(array);
		LIST_ITERATOR KEY_GENERIC_TYPE iter = listIterator();
		for (int i = 0,m=size();i<m && iter.hasNext();i++) {
			iter.NEXT();
			iter.set(array[i]);
		}
	}
	
	public default void unstableSort(Comparator<? super CLASS_TYPE> c) {
		unstableSort((K, V) -> c.compare(KEY_TO_OBJ(K), KEY_TO_OBJ(V)));
	}
	
	public default void unstableSort(COMPARATOR c) {
		KEY_TYPE[] array = TO_ARRAY();
		if(c != null) ARRAYS.unstableSort(array, c);
		else ARRAYS.unstableSort(array);
        LIST_ITERATOR KEY_GENERIC_TYPE iter = listIterator();
        for (int i = 0,m=size();i<m && iter.hasNext();i++) {
        	iter.NEXT();
        	iter.set(array[i]);
        }
	}
	
#endif
	@Override
	public LIST_ITERATOR KEY_GENERIC_TYPE listIterator();
	
	@Override
	public LIST_ITERATOR KEY_GENERIC_TYPE listIterator(int index);
	
	@Override
	public LIST KEY_GENERIC_TYPE subList(int from, int to);
	
	public void size(int size);
	
#if !TYPE_OBJECT
	@Override
	@Deprecated
	public default boolean add(CLASS_TYPE e) {
		return COLLECTION.super.add(e);
	}
	
	@Override
	@Deprecated
	public default CLASS_TYPE get(int index) {
		return KEY_TO_OBJ(GET_KEY(index));
	}
	
	@Override
	@Deprecated
	public default CLASS_TYPE set(int index, CLASS_TYPE e) {
		return KEY_TO_OBJ(set(index, OBJ_TO_KEY(e)));
	}
	
	@Override
	@Deprecated
	public default int indexOf(Object o) {
		return indexOf(CLASS_TO_KEY(o));
	}
	
	@Override
	@Deprecated
	public default int lastIndexOf(Object o) {
		return indexOf(CLASS_TO_KEY(o));
	}
	
	@Override
	@Deprecated
	public default boolean contains(Object o) {
		return COLLECTION.super.contains(o);
	}
	
	@Override
	@Deprecated
	public default boolean remove(Object o) {
		return COLLECTION.super.remove(o);
	}
	
	@Override
	@Deprecated
	public default CLASS_TYPE remove(int index) {
		return KEY_TO_OBJ(REMOVE(index));
	}
	
#if !TYPE_BOOLEAN
	@Override
	@Deprecated
	public default void replaceAll(UnaryOperator<CLASS_TYPE> o) {
		Objects.requireNonNull(o);
#if TYPE_BYTE || TYPE_SHORT || TYPE_CHAR || TYPE_FLOAT
		REPLACE(T -> OBJ_TO_KEY(o.apply(KEY_TO_OBJ((KEY_TYPE)T))));
#else
		REPLACE(T -> OBJ_TO_KEY(o.apply(KEY_TO_OBJ(T))));	
#endif
	}
#endif
#endif
}