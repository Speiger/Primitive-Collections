package speiger.src.collections.PACKAGE.lists;

import java.util.Arrays;
#if TYPE_OBJECT
import java.util.Comparator;
#endif
import java.util.Collection;
import java.util.Iterator;
import java.util.Objects;
#if TYPE_OBJECT
import java.util.function.Consumer;
#endif
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
#if PRIMITIVES
import java.util.function.JAVA_PREDICATE;
import java.util.function.UNARY_OPERATOR;
#endif

import speiger.src.collections.PACKAGE.collections.COLLECTION;
#if !TYPE_OBJECT
import speiger.src.collections.PACKAGE.collections.STACK;
#endif
import speiger.src.collections.PACKAGE.collections.ITERATOR;
#if !TYPE_OBJECT
import speiger.src.collections.PACKAGE.functions.COMPARATOR;
import speiger.src.collections.PACKAGE.functions.CONSUMER;
#endif
import speiger.src.collections.PACKAGE.utils.ARRAYS;
import speiger.src.collections.PACKAGE.utils.ITERATORS;
#if TYPE_OBJECT
import speiger.src.collections.utils.Stack;
#else
import speiger.src.collections.objects.utils.ObjectArrays;
#endif
import speiger.src.collections.PACKAGE.utils.IARRAY;
import speiger.src.collections.utils.SanityChecks;

#if TYPE_OBJECT
public class ARRAY_LIST KEY_GENERIC_TYPE extends ABSTRACT_LIST KEY_GENERIC_TYPE implements IARRAY<KEY_TYPE>, Stack<KEY_TYPE>
#else
public class ARRAY_LIST KEY_GENERIC_TYPE extends ABSTRACT_LIST KEY_GENERIC_TYPE implements IARRAY, STACK
#endif
{
	static final int DEFAULT_ARRAY_SIZE = 10;
	
	protected transient KEY_TYPE[] data;
	protected int size = 0;
	
	public ARRAY_LIST() {
#if TYPE_OBJECT
		data = (KEY_TYPE[])ARRAYS.EMPTY_ARRAY;
#else
		data = ARRAYS.EMPTY_ARRAY;
#endif
	}
	
	public ARRAY_LIST(int size) {
#if TYPE_OBJECT
		data = (KEY_TYPE[])new Object[size];
#else
		data = new KEY_TYPE[size];
#endif
	}
	
	public ARRAY_LIST(Collection<? extends CLASS_TYPE> c) {
		this(c.size());
		size = ITERATORS.unwrap(data, c.iterator());
	}
	
	public ARRAY_LIST(COLLECTION KEY_GENERIC_TYPE c) {
		this(c.size());
		size = ITERATORS.unwrap(data, c.iterator());
	}
	
	public ARRAY_LIST(LIST KEY_GENERIC_TYPE l) {
		this(l.size());
		size = l.size();
		l.getElements(0, data, 0, size);
	}
	
	public ARRAY_LIST(KEY_TYPE[] a)	{
		this(a, 0, a.length);
	}
	
	public ARRAY_LIST(KEY_TYPE[] a, int length) {
		this(a, 0, length);
	}
	
	public ARRAY_LIST(KEY_TYPE[] a, int offset, int length) {
		this(length);
		SanityChecks.checkArrayCapacity(a.length, offset, length);
		System.arraycopy(a, offset, data, 0, length);
		size = length;
	}
	
	public static GENERIC_BRACES ARRAY_LIST KEY_GENERIC_TYPE wrap(KEY_TYPE[] a) {
		return wrap(a, a.length);
	}
	
	public static GENERIC_BRACES ARRAY_LIST KEY_GENERIC_TYPE wrap(KEY_TYPE[] a, int length) {
		SanityChecks.checkArrayCapacity(a.length, 0, length);
		ARRAY_LIST KEY_GENERIC_TYPE list = new ARRAY_LISTBRACES();
		list.data = a;
		list.size = length;
		return list;
	}
	
#if TYPE_OBJECT
	public static GENERIC_BRACES ARRAY_LIST KEY_GENERIC_TYPE of(Class<KEY_TYPE> c) {
		ARRAY_LIST KEY_GENERIC_TYPE list = new ARRAY_LISTBRACES();
		list.data = (KEY_TYPE[])ObjectArrays.newArray(c.getClass().getComponentType(), 0);
		return list;
	}
	
#endif
	@Override
	public void add(int index, CLASS_TYPE element) {
		checkAddRange(index);
		grow(size + 1);
		if(index != size) System.arraycopy(data, index, data, index+1, size - index);
		data[index] = OBJ_TO_KEY(element);
		size++;
	}
	
	@Override
	public boolean add(KEY_TYPE e) {
		grow(size + 1);
		data[size++] = e;
		return true;
	}
	
	@Override
	public void PUSH(KEY_TYPE e) {
		add(e);
	}
	
#if !TYPE_OBJECT
	@Override
	public void add(int index, KEY_TYPE e) {
		checkAddRange(index);
		grow(size + 1);
		if(index != size) System.arraycopy(data, index, data, index+1, size - index);
		data[index] = e;
		size++;
	}
	
#endif	
	@Override
	@Primitive
	public boolean addAll(int index, Collection<? extends CLASS_TYPE> c) {
		if(c instanceof COLLECTION) return addAll(index, (COLLECTION KEY_GENERIC_TYPE)c);
		int add = c.size();
		if(add <= 0) return false;
		grow(size + add);
		if(index != size) System.arraycopy(data, index, data, index+add, size - index);
		size+=add;
		Iterator<? extends CLASS_TYPE> iter = c.iterator();
		while(add != 0) data[index++] = OBJ_TO_KEY(iter.next());
		return true;
	}
	
	@Override
	public boolean addAll(int index, COLLECTION KEY_GENERIC_TYPE c) {
		if(c instanceof LIST) return addAll(index, (LIST KEY_GENERIC_TYPE)c);
		int add = c.size();
		if(add <= 0) return false;
		grow(size + add);
		if(index != size) System.arraycopy(data, index, data, index+add, size - index);
		size+=add;
		ITERATOR KEY_GENERIC_TYPE iter = c.iterator();
		while(add != 0) data[index++] = iter.NEXT();
		return true;
	}
	
	@Override
	public boolean addAll(int index, LIST KEY_GENERIC_TYPE c) {
		int add = c.size();
		if(add <= 0) return false;
		checkAddRange(index);
		grow(size + add);
		if(index != size) System.arraycopy(data, index, data, index+add, size - index);
		size+=add;
		c.getElements(0, data, index, size);
		return true;
	}
	
	@Override
	public void addElements(int from, KEY_TYPE[] a, int offset, int length) {
		if(length <= 0) return;
		checkAddRange(from);
		grow(size + length);
		if(from != size) System.arraycopy(data, from, data, from+length, size - length);
		size+=length;
		System.arraycopy(a, offset, data, from, length);
	}
	
	@Override
	public KEY_TYPE[] getElements(int from, KEY_TYPE[] a, int offset, int length) {
		SanityChecks.checkArrayCapacity(size, offset, length);
		System.arraycopy(data, from, a, offset, length);
		return a;
	}
	
	@Override
	public void removeElements(int from, int to) {
		checkRange(from);
		checkAddRange(to);
		int length = to - from;
		if(length <= 0) return;
		if(to != size) System.arraycopy(data, to, data, from, size - to);
#if TYPE_OBJECT
		for(int i = 0;i<length;i++)
			data[i+to] = null;
#endif
		size -= length;
	}
	
#if TYPE_OBJECT
	@Override
	public KEY_TYPE[] extractElements(int from, int to, Class<KEY_TYPE> type) {
		checkRange(from);
		checkAddRange(to);
		int length = to - from;
		KEY_TYPE[] a = ARRAYS.newArray(type, length);
		if(length <= 0) return a;
		System.arraycopy(data, from, a, 0, length);
		if(to != size) System.arraycopy(data, to, data, from, size - to);
		for(int i = 0;i<length;i++)
			data[i+to] = null;
		size -= length;		
		return a;
	}
	
#else
	@Override
	public KEY_TYPE[] extractElements(int from, int to) {
		int length = to - from;
		if(length <= 0) return ARRAYS.EMPTY_ARRAY;
		KEY_TYPE[] a = new KEY_TYPE[length];
		System.arraycopy(data, from, a, 0, length);
		if(to != size) System.arraycopy(data, to, data, from, size - to);
		size -= length;		
		return a;
	}
	
#endif
	@Override
	@Primitive
	public boolean containsAll(Collection<?> c) {
		if(c instanceof COLLECTION) return containsAll((COLLECTION KEY_GENERIC_TYPE)c);
		Objects.requireNonNull(c);
		for(int i = 0,m=size;i<m;i++) {
#if !TYPE_OBJECT
			if(!c.contains(KEY_TO_OBJ(data[i]))) return false;
#else
			if(!c.contains(data[i])) return false;
#endif
		}
		return true;
	}
	
	@Override
	@Primitive
	public boolean containsAny(Collection<?> c)
	{
		if(c instanceof COLLECTION) return containsAny((COLLECTION KEY_GENERIC_TYPE)c);
		Objects.requireNonNull(c);
		for(int i = 0,m=size;i<m;i++) {
#if !TYPE_OBJECT
			if(c.contains(KEY_TO_OBJ(data[i]))) return true;
#else
			if(c.contains(data[i])) return true;
#endif
		}
		return false;
	}	
	
	@Override
	@Primitive
	public int indexOf(Object o) {
		if(o == null) return -1;
		for(int i = 0;i<size;i++) {
			if(EQUALS_KEY_TYPE(data[i], o)) return i;
		}
		return -1;
	}
	
	@Override
	@Primitive
	public int lastIndexOf(Object o) {
		if(o == null) return -1;
		for(int i = size - 1;i>=0;i--) {
			if(EQUALS_KEY_TYPE(data[i], o)) return i;
		}
		return -1;
	}
	
#if TYPE_OBJECT
	@Override
	public void sort(Comparator<? super CLASS_TYPE> c) {
		if(c != null) ARRAYS.stableSort(data, size, c);
		else ARRAYS.stableSort((Comparable[])data, size);
	}
	
	@Override
	public void unstableSort(Comparator<? super CLASS_TYPE> c) {
		if(c != null) ARRAYS.unstableSort(data, size, c);
		else ARRAYS.unstableSort((Comparable[])data, size);
	}
	
#endif
	@Override
	public boolean containsAll(COLLECTION KEY_GENERIC_TYPE c) {
		Objects.requireNonNull(c);
		for(int i = 0,m=size;i<m;i++) {
			if(!c.contains(data[i])) return false;
		}
		return true;
	}	
	
	@Override
	public boolean containsAny(COLLECTION KEY_GENERIC_TYPE c) {
		Objects.requireNonNull(c);
		for(int i = 0,m=size;i<m;i++) {
			if(c.contains(data[i])) return true;
		}
		return false;
	}
	
#if !TYPE_OBJECT
	@Override
	public int indexOf(KEY_TYPE e) {
		for(int i = 0;i<size;i++) {
			if(EQUALS(data[i], e)) return i;
		}
		return -1;
	}
	
	@Override
	public int lastIndexOf(KEY_TYPE e) {
		for(int i = size - 1;i>=0;i--) {
			if(EQUALS(data[i], e)) return i;
		}
		return -1;
	}
	
	@Override
	public void sort(COMPARATOR c) {
		if(c != null) ARRAYS.stableSort(data, size, c);
		else ARRAYS.stableSort(data, size);
	}
	
	@Override
	public void unstableSort(COMPARATOR c) {
		if(c != null) ARRAYS.unstableSort(data, size, c);
		else ARRAYS.unstableSort(data, size);		
	}
	
#endif
	@Override
	public KEY_TYPE GET_KEY(int index) {
		checkRange(index);
		return data[index];
	}
	
	@Override
	public KEY_TYPE PEEK(int index) {
		checkRange((size() - 1) - index);
		return data[(size() - 1) - index];
	}
	
	@Override
	public KEY_TYPE[] elements() {
		return data;
	}
	
	@Override
	@Primitive
	public void forEach(CONSUMER KEY_SUPER_GENERIC_TYPE action) {
		Objects.requireNonNull(action);
		for(int i = 0;i<size;i++)
			action.accept(data[i]);
	}
	
	@Override
	public KEY_TYPE set(int index, KEY_TYPE e) {
		checkRange(index);
		KEY_TYPE old = data[index];
		data[index] = e;
		return old;
	}
	
	@Override
	public void replaceAll(UnaryOperator<CLASS_TYPE> o) {
		for(int i = 0;i<size;i++)
			data[i] = OBJ_TO_KEY(o.apply(KEY_TO_OBJ(data[i])));
	}
	
#if PRIMITIVES	
	@Override
	public void REPLACE(UNARY_OPERATOR o) {
		for(int i = 0;i<size;i++)
#if TYPE_BYTE || TYPE_SHORT || TYPE_CHAR || TYPE_FLOAT
			data[i] = SanityChecks.SANITY_CAST(o.APPLY(data[i]));
#else
	data[i] = o.APPLY(data[i]);
#endif
	}
	
#endif
	@Override
	public KEY_TYPE REMOVE(int index) {
		checkRange(index);
		KEY_TYPE old = data[index];
		if(index != size - 1) System.arraycopy(data, index+1, data, index, size - index);
#if TYPE_OBJECT
		data[size] = null;
#endif
		size--;
		return old;
	}
	
	@Override
	public KEY_TYPE POP() {
		return REMOVE(size() - 1);
	}
	
	@Override
	@Primitive
	public boolean removeAll(Collection<?> c) {
		if(c.isEmpty()) return false;
		if(c instanceof COLLECTION) return removeAll((COLLECTION KEY_GENERIC_TYPE)c);
		boolean modified = false;
		for(int i = 0, j = 0;i<size;i++) {
			if(!c.contains(KEY_TO_OBJ(data[i]))) {
				data[j++] = data[i];
				modified = true;
			}
		}
		return modified;
	}
	
	@Override
	@Primitive
	public boolean retainAll(Collection<?> c) {
		if(c.isEmpty()) {
			boolean modifed = size > 0;
			clear();
			return modifed;
		}
		if(c instanceof COLLECTION) return retainAll((COLLECTION KEY_GENERIC_TYPE)c);
		boolean modified = false;
		for(int i = 0, j = 0;i<size;i++) {
			if(c.contains(KEY_TO_OBJ(data[i]))) {
				data[j++] = data[i];
				modified = true;
			}
		}
		return modified;
	}
	
	@Override
	@Primitive
	public boolean removeIf(Predicate<? super CLASS_TYPE> filter) {
		Objects.requireNonNull(filter);
		boolean modified = false;
		for(int i = 0, j = 0;i<size;i++) {
			if(!filter.test(KEY_TO_OBJ(data[i]))) {
				data[j++] = data[i];
				modified = true;
			}
		}
		return modified;
	}
	
	@Override
	public boolean removeAll(COLLECTION KEY_GENERIC_TYPE c) {
		if(c.isEmpty()) return false;
		boolean modified = false;
		for(int i = 0, j = 0;i<size;i++) {
			if(!c.contains(data[i])) {
				data[j++] = data[i];
				modified = true;
			}
		}
		return modified;
	}
	
	@Override
	public boolean retainAll(COLLECTION KEY_GENERIC_TYPE c) {
		if(c.isEmpty()) {
			boolean modifed = size > 0;
			clear();
			return modifed;
		}
		boolean modified = false;
		for(int i = 0, j = 0;i<size;i++) {
			if(c.contains(data[i])) {
				data[j++] = data[i];
				modified = true;
			}
		}
		return modified;
	}
	
#if PRIMITIVES
	@Override
	public boolean remIf(JAVA_PREDICATE filter) {
		Objects.requireNonNull(filter);
		boolean modified = false;
		for(int i = 0, j = 0;i<size;i++) {
			if(!filter.test(data[i])) {
				data[j++] = data[i];
				modified = true;
			}
		}
		return modified;
	}
	
#endif
	@Override
	@Primitive
	public Object[] toArray() {
		Object[] obj = new Object[size];
		for(int i = 0;i<size;i++)
			obj[i] = KEY_TO_OBJ(data[i]);
		return obj;
	}
	
	@Override
	@Primitive
	public <E> E[] toArray(E[] a) {
		if(a == null) a = (E[])new Object[size];
		else if(a.length < size) a = (E[])ObjectArrays.newArray(a.getClass().getComponentType(), size);
		for(int i = 0;i<size;i++)
			a[i] = (E)KEY_TO_OBJ(data[i]);
		return a;
	}
	
#if !TYPE_OBJECT
	@Override
	public KEY_TYPE[] TO_ARRAY(KEY_TYPE[] a) {
		if(a.length < size) a = new KEY_TYPE[size];
		System.arraycopy(data, 0, a, 0, size);
		return a;
	}
	
#endif
	@Override
	public int size() {
		return size;
	}
	
	@Override
	public void size(int size) {
		if(size > data.length)
			data = Arrays.copyOf(data, size);
		else if(size < size() && size >= 0)
			Arrays.fill(data, size, size(), EMPTY_VALUE);
	}
	
	@Override
	public void clear() {
#if TYPE_OBJECT
		for(int i = 0;i<size;data[i] = null,i++);
#endif
		size = 0;
	}
	
	@Override
	public void trim(int size) {
		if(size > size() || size() == data.length) return;
		int value = Math.min(size, size());
#if TYPE_OBJECT
		data = value == 0 ? (KEY_TYPE[])ARRAYS.EMPTY_ARRAY : Arrays.copyOf(data, value);
#else
		data = value == 0 ? ARRAYS.EMPTY_ARRAY : Arrays.copyOf(data, value);
#endif
	}
	
	@Override
	public void ensureCapacity(int size) {
		grow(size);
	}
	
	protected void grow(int capacity) {
		if(capacity < data.length) return;
		data = Arrays.copyOf(data, data == ARRAYS.EMPTY_ARRAY ? DEFAULT_ARRAY_SIZE : (int)Math.max(Math.min((long)data.length + (data.length >> 1), SanityChecks.MAX_ARRAY_SIZE), capacity));		
	}
	
	protected void checkRange(int index) {
		if (index < 0 || index >= size)
			throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
	}
	
	protected void checkAddRange(int index) {
		if (index < 0 || index > size)
			throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
	}
}