package speiger.src.collections.PACKAGE.lists;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;

import speiger.src.collections.PACKAGE.collections.COLLECTION;
#if !TYPE_OBJECT
import speiger.src.collections.PACKAGE.collections.STACK;
#endif
import speiger.src.collections.PACKAGE.collections.ITERATOR;
import speiger.src.collections.PACKAGE.utils.ARRAYS;
import speiger.src.collections.PACKAGE.utils.ITERATORS;
#if TYPE_OBJECT
import speiger.src.collections.utils.Stack;
#endif
import speiger.src.collections.utils.IArray;
import speiger.src.collections.utils.SanityChecks;

#if TYPE_OBJECT
public class ARRAY_LIST KEY_GENERIC_TYPE extends ABSTRACT_LIST KEY_GENERIC_TYPE implements IArray, Stack<KEY_TYPE>
#else
public class ARRAY_LIST KEY_GENERIC_TYPE extends ABSTRACT_LIST KEY_GENERIC_TYPE implements IArray, STACK
#endif
{
	static final int DEFAULT_ARRAY_SIZE = 10;
	
	protected transient KEY_TYPE[] data;
	protected int size = 0;
	
	public ARRAY_LIST() {
#if TYPE_OBJECT
		data = (KEY_TYPE[])ARRAYS.EMPTY_ARRAY;
#else
		data = ARRAYS.EMPTY_ARRAY;
#endif
	}
	
	public ARRAY_LIST(int size) {
#if TYPE_OBJECT
		data = (KEY_TYPE[])new Object[size];
#else
		data = new KEY_TYPE[size];
#endif
	}
	
	public ARRAY_LIST(Collection<? extends CLASS_TYPE> c) {
		this(c.size());
		size = ITERATORS.unwrap(data, c.iterator());
	}
	
	public ARRAY_LIST(COLLECTION KEY_GENERIC_TYPE c) {
		this(c.size());
		size = ITERATORS.unwrap(data, c.iterator());
	}
	
	public ARRAY_LIST(LIST KEY_GENERIC_TYPE l) {
		this(l.size());
		size = l.size();
		l.getElements(0, data, 0, size);
	}
	
	public ARRAY_LIST(KEY_TYPE[] a)	{
		this(a, 0, a.length);
	}
	
	public ARRAY_LIST(KEY_TYPE[] a, int length) {
		this(a, 0, length);
	}
	
	public ARRAY_LIST(KEY_TYPE[] a, int offset, int length) {
		this(length);
		SanityChecks.checkArrayCapacity(a.length, offset, length);
		System.arraycopy(a, offset, data, 0, length);
		size = length;
	}
	
	public static GENERIC_BRACES ARRAY_LIST KEY_GENERIC_TYPE wrap(KEY_TYPE[] a) {
		return wrap(a, a.length);
	}
	
	public static GENERIC_BRACES ARRAY_LIST KEY_GENERIC_TYPE wrap(KEY_TYPE[] a, int length) {
		SanityChecks.checkArrayCapacity(a.length, 0, length);
		ARRAY_LIST KEY_GENERIC_TYPE list = new ARRAY_LISTBRACES();
		list.data = a;
		list.size = length;
		return list;
	}
	
	@Override
	public void add(int index, CLASS_TYPE element) {
		checkAddRange(index);
		grow(size + 1);
		if(index != size) System.arraycopy(data, index, data, index+1, size - index);
		data[index] = OBJ_TO_KEY(element);
		size++;
	}
	
	@Override
	public boolean add(KEY_TYPE e) {
		grow(size + 1);
		data[size++] = e;
		return true;
	}
	
#if !TYPE_OBJECT
	@Override
	public void add(int index, KEY_TYPE e) {
		checkAddRange(index);
		grow(size + 1);
		if(index != size) System.arraycopy(data, index, data, index+1, size - index);
		data[index] = e;
		size++;
	}
	
#endif	
	@Override
	public boolean addAll(int index, Collection<? extends CLASS_TYPE> c) {
		if(c instanceof COLLECTION) return addAll(index, (COLLECTION KEY_GENERIC_TYPE)c);
		int add = c.size();
		if(add <= 0) return false;
		grow(size + add);
		if(index != size) System.arraycopy(data, index, data, index+add, size - index);
		size+=add;
		Iterator<? extends CLASS_TYPE> iter = c.iterator();
		while(add != 0) data[index++] = OBJ_TO_KEY(iter.next());
		return true;
	}
	
	@Override
	public boolean addAll(int index, COLLECTION KEY_GENERIC_TYPE c) {
		if(c instanceof LIST) return addAll(index, (LIST KEY_GENERIC_TYPE)c);
		int add = c.size();
		if(add <= 0) return false;
		grow(size + add);
		if(index != size) System.arraycopy(data, index, data, index+add, size - index);
		size+=add;
		ITERATOR KEY_GENERIC_TYPE iter = c.iterator();
		while(add != 0) data[index++] = iter.NEXT();
		return true;
	}
	
	@Override
	public boolean addAll(int index, LIST KEY_GENERIC_TYPE c) {
		int add = c.size();
		if(add <= 0) return false;
		checkAddRange(index);
		grow(size + add);
		if(index != size) System.arraycopy(data, index, data, index+add, size - index);
		size+=add;
		c.getElements(0, data, index, size);
		return true;
	}
	
	@Override
	public void addElements(int from, KEY_TYPE[] a, int offset, int length) {
		if(length <= 0) return;
		checkAddRange(from);
		grow(size + length);
		if(from != size) System.arraycopy(data, from, data, from+length, size - length);
		size+=length;
		System.arraycopy(a, offset, data, from, length);
	}
	
	@Override
	public KEY_TYPE[] getElements(int from, KEY_TYPE[] a, int offset, int length) {
		SanityChecks.checkArrayCapacity(size, offset, length);
		System.arraycopy(data, from, a, offset, length);
		return a;
	}
	
	@Override
	public void removeElements(int from, int to) {
		checkRange(from);
		checkAddRange(to);
		int length = to - from;
		if(length <= 0) return;
		if(to != size) System.arraycopy(data, to, data, from, size - to);
#if TYPE_OBJECT
		for(int i = 0;i<length;i++)
			data[i+to] = null;
#endif
		size -= length;
	}
	
#if TYPE_OBJECT
	@Override
	public KEY_TYPE[] extractElements(int from, int to, Class<KEY_TYPE> type) {
		checkRange(from);
		checkAddRange(to);
		int length = to - from;
		KEY_TYPE[] a = ARRAYS.newArray(type, length);
		if(length <= 0) return a;
		System.arraycopy(data, from, a, 0, length);
		if(to != size) System.arraycopy(data, to, data, from, size - to);
		for(int i = 0;i<length;i++)
			data[i+to] = null;
		size -= length;		
		return a;
	}
	
#else
	@Override
	public KEY_TYPE[] extractElements(int from, int to) {
		int length = to - from;
		if(length <= 0) return ARRAYS.EMPTY_ARRAY;
		KEY_TYPE[] a = new KEY_TYPE[length];
		System.arraycopy(data, from, a, 0, length);
		if(to != size) System.arraycopy(data, to, data, from, size - to);
		size -= length;		
		return a;
	}
	
#endif
	@Override
	public KEY_TYPE GET_KEY(int index) {
		checkRange(index);
		return data[index];
	}
	
	@Override
	public KEY_TYPE set(int index, KEY_TYPE e) {
		checkRange(index);
		KEY_TYPE old = data[index];
		data[index] = e;
		return old;
	}
	
	@Override
	public KEY_TYPE REMOVE(int index) {
		checkRange(index);
		KEY_TYPE old = data[index];
		if(index != size) System.arraycopy(data, index+1, data, index, size - index);
#if TYPE_OBJECT
		data[size] = null;
#endif
		size--;
		return old;
	}
	
	@Override
	public int size() {
		return size;
	}
	
	@Override
	public void size(int size) {
		if(size > data.length)
			data = Arrays.copyOf(data, size);
		else if(size < size() && size >= 0)
			Arrays.fill(data, size, size(), EMPTY_VALUE);
	}
	
	@Override
	public void clear() {
#if TYPE_OBJECT
		for(int i = 0;i<size;data[i] = null,i++);
#endif
		size = 0;
	}
	
	@Override
	public void trim(int size) {
		if(size > size() || size() == data.length) return;
		int value = Math.min(size, size());
#if TYPE_OBJECT
		data = value == 0 ? (KEY_TYPE[])ARRAYS.EMPTY_ARRAY : Arrays.copyOf(data, value);
#else
		data = value == 0 ? ARRAYS.EMPTY_ARRAY : Arrays.copyOf(data, value);
#endif
	}
	
	@Override
	public void ensureCapacity(int size) {
		grow(size);
	}
	
	@Override
	public void PUSH(KEY_TYPE e) {
		add(e);
	}

	@Override
	public KEY_TYPE POP() {
		return REMOVE(size() - 1);
	}

	@Override
	public KEY_TYPE PEEK(int index) {
		checkRange((size() - 1) - index);
		return data[(size() - 1) - index];
	}
	
	protected void grow(int capacity)
	{
		if(capacity < data.length) return;
		data = Arrays.copyOf(data, data == ARRAYS.EMPTY_ARRAY ? DEFAULT_ARRAY_SIZE : (int)Math.max(Math.min((long)data.length + (data.length >> 1), SanityChecks.MAX_ARRAY_SIZE), capacity));		
	}
	
	protected void checkRange(int index) {
		if (index < 0 || index >= size)
			throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
	}
	
	protected void checkAddRange(int index) {
		if (index < 0 || index > size)
			throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
	}
}