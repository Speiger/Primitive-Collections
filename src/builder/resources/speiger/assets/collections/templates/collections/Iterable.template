package speiger.src.collections.PACKAGE.collections;

import java.util.Objects;
#if !TYPE_OBJECT
import java.util.function.Consumer;

import speiger.src.collections.PACKAGE.functions.CONSUMER;
#else 
import java.util.function.Function;
import speiger.src.collections.PACKAGE.utils.ITERABLES;
#endif
import speiger.src.collections.PACKAGE.functions.consumer.BI_OBJECT_CONSUMER;
import speiger.src.collections.PACKAGE.functions.function.PREDICATE;
import speiger.src.collections.PACKAGE.collections.SPLIT_ITERATOR;
import speiger.src.collections.PACKAGE.utils.SPLIT_ITERATORS;

/**
 * A Type-Specific {@link Iterable} that reduces (un)boxing
 * @Type(T)
 */
public interface ITERABLE KEY_GENERIC_TYPE extends Iterable<CLASS_TYPE>
{
    /**
     * Returns an iterator over elements of type {@code T}.
     *
     * @return an Iterator.
     */
	@Override
	ITERATOR KEY_GENERIC_TYPE iterator();
	
#if !TYPE_OBJECT
	/**
	 * A Type Specific foreach function that reduces (un)boxing
	 * 
     * @implSpec
     * <p>The default implementation behaves as if:
     * <pre>{@code
     *     iterator().forEachRemaining(action);
     * }</pre>
     *
     * @param action The action to be performed for each element
     * @throws NullPointerException if the specified action is null
     * @see Iterable#forEach(Consumer)
     */
	default void forEach(CONSUMER action) {
		Objects.requireNonNull(action);
		iterator().forEachRemaining(action);
	}
	
	/** {@inheritDoc}
	* <p>This default implementation delegates to the corresponding type-specific function.
	* @deprecated Please use the corresponding type-specific function instead. 
	*/
	@Deprecated
	@Override
    default void forEach(Consumer<? super CLASS_TYPE> action) {
        Objects.requireNonNull(action);
        iterator().forEachRemaining(action);
    }
	
#endif
	/**
	 * Helper function to reduce Lambda usage and allow for more method references, since these are faster/cleaner.
	 * @param input the object that should be included
	 * @param action The action to be performed for each element
	 * @param <E> the generic type of the Object
	 * @throws java.lang.NullPointerException if the specified action is null
	 */
	default <E> void forEach(E input, BI_OBJECT_CONSUMER KEY_VALUE_SPECIAL_GENERIC_TYPE action) {
		Objects.requireNonNull(action);
		iterator().forEachRemaining(input, action);
	}
	
	/**
	 * A Type Specific Type Splititerator to reduce boxing/unboxing
	 * @return type specific splititerator
	 */
	@Override
	default SPLIT_ITERATOR KEY_GENERIC_TYPE spliterator() { return SPLIT_ITERATORS.createUnknownSplititerator(iterator(), 0); }

#if TYPE_OBJECT
	/**
	 * A Helper function to reduce the usage of Streams and allows to convert a Iterable to something else.
	 * @param map the mapping function
	 * @Type(E)
	 * @return a new Iterable that returns the desired result
	 */
	default <E> ObjectIterable<E> map(Function<T, E> map) {
		return ObjectIterables.map(this, map);
	}
	
	/**
	 * A Helper function to reduce the usage of Streams and allows to convert a Iterable to something else.
	 * @param map the flatMapping function
	 * @Type(E)
	 * @Type(V)
	 * @return a new Iterable that returns the desired result
	 */
	default <E, V extends Iterable<E>> ObjectIterable<E> flatMap(Function<T, V> map) {
		return ObjectIterables.flatMap(this, map);
	}
	
	/**
	 * A Helper function to reduce the usage of Streams and allows to convert a Iterable to something else.
	 * @param map the flatMapping function
	 * @Type(E)
	 * @return a new Iterable that returns the desired result
	 */
	default <E> ObjectIterable<E> arrayflatMap(Function<T, E[]> map) {
		return ObjectIterables.arrayFlatMap(this, map);
	}
	
#endif
	/**
	 * Helper function to reduce stream usage that allows to filter for any matches.
	 * @param filter that should be applied
	 * @return true if any matches were found
	 */
	default boolean matchesAny(PREDICATE KEY_GENERIC_TYPE filter) {
		Objects.requireNonNull(filter);
		for(ITERATOR KEY_GENERIC_TYPE iter = iterator();iter.hasNext();) {
			if(filter.TEST_VALUE(iter.NEXT())) return true;
		}
		return false;
	}
	
	/**
	 * Helper function to reduce stream usage that allows to filter for no matches.
	 * @param filter that should be applied
	 * @return true if no matches were found
	 */
	default boolean matchesNone(PREDICATE KEY_GENERIC_TYPE filter) {
		Objects.requireNonNull(filter);
		for(ITERATOR KEY_GENERIC_TYPE iter = iterator();iter.hasNext();) {
			if(filter.TEST_VALUE(iter.NEXT())) return false;
		}
		return true;
	}
	
	/**
	 * Helper function to reduce stream usage that allows to filter for all matches.
	 * @param filter that should be applied
	 * @return true if all matches.
	 */
	default boolean matchesAll(PREDICATE KEY_GENERIC_TYPE filter) {
		Objects.requireNonNull(filter);
		for(ITERATOR KEY_GENERIC_TYPE iter = iterator();iter.hasNext();) {
			if(!filter.TEST_VALUE(iter.NEXT())) return false;
		}
		return true;
	}
	
	/**
	 * Helper function to reduce stream usage that allows to filter for the first match.
	 * @param filter that should be applied
	 * @return the found value or the null equivalent variant.
	 */
	default KEY_TYPE findFirst(PREDICATE KEY_GENERIC_TYPE filter) {
		Objects.requireNonNull(filter);
		for(ITERATOR KEY_GENERIC_TYPE iter = iterator();iter.hasNext();) {
			KEY_TYPE entry = iter.NEXT();
			if(filter.TEST_VALUE(entry)) return entry;
		}
		return EMPTY_VALUE;
	}
}