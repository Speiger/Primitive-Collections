package speiger.src.collections.PACKAGE.utils;

import java.util.Iterator;
import java.util.NoSuchElementException;
import speiger.src.collections.PACKAGE.collections.ITERATOR;
import speiger.src.collections.PACKAGE.lists.ARRAY_LIST;
import speiger.src.collections.PACKAGE.lists.LIST;
import speiger.src.collections.PACKAGE.lists.LIST_ITERATOR;
import speiger.src.collections.PACKAGE.collections.BI_ITERATOR;
import speiger.src.collections.PACKAGE.collections.COLLECTION;

/**
 * A Helper class for Iterators
 */
public class ITERATORS
{
	/**
	 * Empty Iterator Reference
	 */
	public static final EmptyIterator NO_GENERIC_TYPE EMPTY = new EmptyIteratorBRACES();
	
	/**
	 * Returns a Immutable EmptyIterator instance that is automatically casted.
	 * @Type(T)
	 * @return an empty iterator
	 */
	public static GENERIC_KEY_BRACES EmptyIterator KEY_GENERIC_TYPE empty() {
#if TYPE_OBJECT
		return (EmptyIterator<KEY_TYPE>)EMPTY;
#else
		return EMPTY;
#endif
	}
	
	/**
	 * Inverter function for Bidirectional Iterators
	 * @param it the iterator that should be inverted
	 * @Type(T)
	 * @return a Inverted Bidirectional Iterator. If it was inverted then it just gives back the original reference
	 */
	public static GENERIC_KEY_BRACES BI_ITERATOR KEY_GENERIC_TYPE invert(BI_ITERATOR KEY_GENERIC_TYPE it) {
		return it instanceof ReverseBiIterator ? ((ReverseBiIterator KEY_GENERIC_TYPE)it).it : new ReverseBiIteratorBRACES(it);
	}
	
	/**
	 * Inverter function for List Iterators
	 * @param it the iterator that should be inverted
	 * @Type(T)
	 * @return a Inverted List Iterator. If it was inverted then it just gives back the original reference
	 */
	public static GENERIC_KEY_BRACES LIST_ITERATOR KEY_GENERIC_TYPE invert(LIST_ITERATOR KEY_GENERIC_TYPE it) {
		return it instanceof ReverseListIterator ? ((ReverseListIterator KEY_GENERIC_TYPE)it).it : new ReverseListIteratorBRACES(it);
	}
	
	/**
	 * Returns a Immutable Iterator instance based on the instance given.
	 * @param iterator that should be made immutable/unmodifiable
	 * @Type(T)
	 * @return a unmodifiable iterator wrapper. If the Iterator already a unmodifiable wrapper then it just returns itself.
	 */
	public static GENERIC_KEY_BRACES ITERATOR KEY_GENERIC_TYPE unmodifiable(ITERATOR KEY_GENERIC_TYPE iterator) {
		return iterator instanceof UnmodifiableIterator ? iterator : new UnmodifiableIteratorBRACES(iterator);
	}
	
	/**
	 * Returns a Immutable Iterator instance based on the instance given.
	 * @param iterator that should be made immutable/unmodifiable
	 * @Type(T)
	 * @return a unmodifiable iterator wrapper. If the Iterator already a unmodifiable wrapper then it just returns itself.
	 */
	public static GENERIC_KEY_BRACES BI_ITERATOR KEY_GENERIC_TYPE unmodifiable(BI_ITERATOR KEY_GENERIC_TYPE iterator) {
		return iterator instanceof UnmodifiableBiIterator ? iterator : new UnmodifiableBiIteratorBRACES(iterator);
	}
	
	/**
	 * Returns a Immutable ListIterator instance based on the instance given.
	 * @param iterator that should be made immutable/unmodifiable
	 * @Type(T)
	 * @return a unmodifiable listiterator wrapper. If the ListIterator already a unmodifiable wrapper then it just returns itself.
	 */
	public static GENERIC_KEY_BRACES LIST_ITERATOR KEY_GENERIC_TYPE unmodifiable(LIST_ITERATOR KEY_GENERIC_TYPE iterator) {
		return iterator instanceof UnmodifiableListIterator ? iterator : new UnmodifiableListIteratorBRACES(iterator);
	}
		/**
	 * Helper function to convert a Object Iterator into a Primitive Iterator
	 * @param iterator that should be converted to a unboxing iterator
	 * @ArrayType(T)
	 * @return a primitive iterator
	 */
	public static GENERIC_KEY_BRACES ITERATOR KEY_GENERIC_TYPE wrap(Iterator<? extends CLASS_TYPE> iterator) {
		return iterator instanceof ITERATOR ? (ITERATOR KEY_GENERIC_TYPE)iterator : new IteratorWrapperBRACES(iterator);
	}
	
	/**
	 * Returns a Array Wrapping iterator
	 * @param a the array that should be wrapped
	 * @ArrayType(T)
	 * @return a Iterator that is wrapping a array.
	 */
	public static GENERIC_KEY_BRACES ArrayIterator KEY_GENERIC_TYPE wrap(KEY_TYPE[] a) {
		return wrap(a, 0, a.length);
	}
	
	/**
	 * Returns a Array Wrapping iterator
	 * @param a the array that should be wrapped.
	 * @param start the index to be started from.
	 * @param end the index that should be ended.
	 * @ArrayType(T)
	 * @return a Iterator that is wrapping a array.
	 */
	public static GENERIC_KEY_BRACES ArrayIterator KEY_GENERIC_TYPE wrap(KEY_TYPE[] a, int start, int end) {
		return new ArrayIteratorBRACES(a, start, end);
	}
	
	/**
	 * Iterates over a iterator and inserts the values into the array and returns the amount that was inserted
	 * @param a where the elements should be inserted
	 * @param i the source iterator
	 * @ArrayType(T)
	 * @return the amount of elements that were inserted into the array.
	 */
	public static GENERIC_KEY_BRACES int unwrap(KEY_TYPE[] a, Iterator<? extends CLASS_TYPE> i) {
		return unwrap(a, i, 0, a.length);
	}
	
	/**
	 * Iterates over a iterator and inserts the values into the array and returns the amount that was inserted
	 * @param a where the elements should be inserted
	 * @param i the source iterator
	 * @param offset the array offset where the start should be
	 * @ArrayType(T)
	 * @return the amount of elements that were inserted into the array.
	 */
	public static GENERIC_KEY_BRACES int unwrap(KEY_TYPE[] a, Iterator<? extends CLASS_TYPE> i, int offset) {
		return unwrap(a, i, offset, a.length - offset);
	}
	
	/**
	 * Iterates over a iterator and inserts the values into the array and returns the amount that was inserted
	 * @param a where the elements should be inserted
	 * @param i the source iterator
	 * @param offset the array offset where the start should be
	 * @param max the maximum values that should be extracted from the source
	 * @ArrayType(T)
	 * @return the amount of elements that were inserted into the array.
	 * @throws IllegalStateException if max is smaller the 0 or if the maximum index is larger then the array
	 */
	public static GENERIC_KEY_BRACES int unwrap(KEY_TYPE[] a, Iterator<? extends CLASS_TYPE> i, int offset, int max) {
		if(max < 0) throw new IllegalStateException("The max size is smaller then 0");
		if(offset + max > a.length) throw new IllegalStateException("largest array index exceeds array size");
		int index = 0;
		for(;index<max && i.hasNext();index++) a[index+offset] = OBJ_TO_KEY(i.next());
		return index;
	}
	
	/**
	 * A Primitive iterator variant of the ITERATORS unwrap function
	 * Iterates over a iterator and inserts the values into the array and returns the amount that was inserted
	 * @param a where the elements should be inserted
	 * @param i the source iterator
	 * @ArrayType(T)
	 * @return the amount of elements that were inserted into the array.
	 */
	public static GENERIC_KEY_BRACES int unwrap(KEY_TYPE[] a, ITERATOR KEY_GENERIC_TYPE i) {
		return unwrap(a, i, 0, a.length);
	}
	
	/**
	 * A Primitive iterator variant of the ITERATORS unwrap function
	 * Iterates over a iterator and inserts the values into the array and returns the amount that was inserted
	 * @param a where the elements should be inserted
	 * @param i the source iterator
	 * @param offset the array offset where the start should be
	 * @ArrayType(T)
	 * @return the amount of elements that were inserted into the array.
	 */
	public static GENERIC_KEY_BRACES int unwrap(KEY_TYPE[] a, ITERATOR KEY_GENERIC_TYPE i, int offset) {
		return unwrap(a, i, offset, a.length - offset);
	}
	
	/**
	 * A Primitive iterator variant of the ITERATORS unwrap function
	 * Iterates over a iterator and inserts the values into the array and returns the amount that was inserted
	 * @param a where the elements should be inserted
	 * @param i the source iterator
	 * @param offset the array offset where the start should be
	 * @param max the maximum values that should be extracted from the source
	 * @ArrayType(T)
	 * @return the amount of elements that were inserted into the array.
	 * @throws IllegalStateException if max is smaller the 0 or if the maximum index is larger then the array
	 */
	public static GENERIC_KEY_BRACES int unwrap(KEY_TYPE[] a, ITERATOR KEY_GENERIC_TYPE i, int offset, int max) {
		if(max < 0) throw new IllegalStateException("The max size is smaller then 0");
		if(offset + max > a.length) throw new IllegalStateException("largest array index exceeds array size");
		int index = 0;
		for(;index<max && i.hasNext();index++) a[index+offset] = i.NEXT();
		return index;
	}
	
#if !TYPE_OBJECT
	/**
	 * A Function to convert a Primitive Iterator to a Object array.
	 * Iterates over a iterator and inserts the values into the array and returns the amount that was inserted
	 * @param a where the elements should be inserted
	 * @param i the source iterator
	 * @ArrayType(T)
	 * @return the amount of elements that were inserted into the array.
	 */
	public static GENERIC_KEY_BRACES int unwrap(CLASS_TYPE[] a, ITERATOR KEY_GENERIC_TYPE i) {
		return unwrap(a, i, 0, a.length);
	}
	
	/**
	 * A Function to convert a Primitive Iterator to a Object array.
	 * Iterates over a iterator and inserts the values into the array and returns the amount that was inserted
	 * @param a where the elements should be inserted
	 * @param i the source iterator
	 * @param offset the array offset where the start should be
	 * @ArrayType(T)
	 * @return the amount of elements that were inserted into the array.
	 */
	public static GENERIC_KEY_BRACES int unwrap(CLASS_TYPE[] a, ITERATOR KEY_GENERIC_TYPE i, int offset) {
		return unwrap(a, i, offset, a.length - offset);
	}
	
	/**
	 * A Function to convert a Primitive Iterator to a Object array.
	 * Iterates over a iterator and inserts the values into the array and returns the amount that was inserted
	 * @param a where the elements should be inserted
	 * @param i the source iterator
	 * @param offset the array offset where the start should be
	 * @param max the maximum values that should be extracted from the source
	 * @ArrayType(T)
	 * @return the amount of elements that were inserted into the array.
	 * @throws IllegalStateException if max is smaller the 0 or if the maximum index is larger then the array
	 */
	public static GENERIC_KEY_BRACES int unwrap(CLASS_TYPE[] a, ITERATOR KEY_GENERIC_TYPE i, int offset, int max) {
		if(max < 0) throw new IllegalStateException("The max size is smaller then 0");
		if(offset + max > a.length) throw new IllegalStateException("largest array index exceeds array size");
		int index = 0;
		for(;index<max && i.hasNext();index++) a[index+offset] = KEY_TO_OBJ(i.NEXT());
		return index;
	}
	
#endif
	/**
	 * A Helper function to pours all elements of a Iterator into a List
	 * @param iter the elements that should be poured into list.
	 * @ArrayType(T)
	 * @return A list of all elements of the Iterator
	 */
	public static GENERIC_KEY_BRACES LIST KEY_GENERIC_TYPE pour(ITERATOR KEY_GENERIC_TYPE iter) {
		return pour(iter, Integer.MAX_VALUE);
	}
	
	/**
	 * A Helper function to pours all elements of a Iterator into a List
	 * @param iter the elements that should be poured into list.
	 * @param max the maximum amount of elements that should be collected
	 * @ArrayType(T)
	 * @return A list of all requested elements of the Iterator
	 */
	public static GENERIC_KEY_BRACES LIST KEY_GENERIC_TYPE pour(ITERATOR KEY_GENERIC_TYPE iter, int max) {
		ARRAY_LIST KEY_GENERIC_TYPE list = new ARRAY_LISTBRACES();
		pour(iter, list, max);
		list.trim();
		return list;
	}
	
	/**
	 * A Helper function to pours all elements of a Iterator into a Collection
	 * @param iter the elements that should be poured into list.
	 * @param c the collection where the elements should be poured into
	 * @ArrayType(T)
	 * @return the amount of elements that were added
	 */
	public static GENERIC_KEY_BRACES int pour(ITERATOR KEY_GENERIC_TYPE iter, COLLECTION KEY_GENERIC_TYPE c) {
		return pour(iter, c, Integer.MAX_VALUE);
	}
	
	/**
	 * A Helper function to pours all elements of a Iterator into a Collection
	 * @param iter the elements that should be poured into list.
	 * @param c the collection where the elements should be poured into
	 * @param max the maximum amount of elements that should be collected
	 * @ArrayType(T)
	 * @return the amount of elements that were added
	 */
	public static GENERIC_KEY_BRACES int pour(ITERATOR KEY_GENERIC_TYPE iter, COLLECTION KEY_GENERIC_TYPE c, int max) {
		if(max < 0) throw new IllegalStateException("Max is negative");
		int done = 0;
		for(;done<max && iter.hasNext();done++, c.add(iter.NEXT()));
		return done;
	}
	
	/**
	 * Helper Iterator that concats other iterators together
	 * @param array the Iterators that should be concatenated
	 * @ArrayType(T)
	 * @return iterator of the inputted iterators
	 */
	public static GENERIC_KEY_BRACES ITERATOR KEY_GENERIC_TYPE concat(ITERATOR KEY_GENERIC_TYPE... array) {
		return concat(array, 0, array.length);
	}
	
	/**
	 * Helper Iterator that concats other iterators together
	 * @param array the Iterators that should be concatenated
	 * @param offset where to start within the array
	 * @param length the length of the array
	 * @ArrayType(T)
	 * @return iterator of the inputted iterators
	 */
	public static GENERIC_KEY_BRACES ITERATOR KEY_GENERIC_TYPE concat(ITERATOR KEY_GENERIC_TYPE[] array, int offset, int length) {
		return new ConcatIteratorBRACES(array, offset, length);
	}
	
	private static class IteratorWrapper KEY_GENERIC_TYPE implements ITERATOR KEY_GENERIC_TYPE
	{
		Iterator<? extends CLASS_TYPE> iter;
		
		public IteratorWrapper(Iterator<? extends CLASS_TYPE> iter) {
			this.iter = iter;
		}
		
		@Override
		public boolean hasNext() {
			return iter.hasNext();
		}
		
		@Override
		public KEY_TYPE NEXT() {
			return OBJ_TO_KEY(iter.next());
		}
		
#if !TYPE_OBJECT
		@Override
		@Deprecated
		public CLASS_TYPE next() {
			return iter.next();
		}
#endif
	}
	
	private static class ConcatIterator KEY_GENERIC_TYPE implements ITERATOR KEY_GENERIC_TYPE
	{
		ITERATOR KEY_GENERIC_TYPE[] iters;
		int offset;
		int lastOffset = -1;
		int length;
		
		public ConcatIterator(ITERATOR KEY_GENERIC_TYPE[] iters, int offset, int length) {
			this.iters = iters;
			this.offset = offset;
			this.length = length;
			find();
		}
		
		private void find() {
			for(;length != 0 && !iters[offset].hasNext();length--, offset++);
		}
		
		@Override
		public boolean hasNext() {
			return length > 0;
		}
		
		@Override
		public KEY_TYPE NEXT() {
			if(!hasNext()) throw new NoSuchElementException();
			KEY_TYPE result = iters[lastOffset = offset].NEXT();
			find();
			return result;
		}
		
		@Override
		public void remove() {
			if(lastOffset == -1) throw new IllegalStateException();
			iters[lastOffset].remove();
			lastOffset = -1;
		}
	}
	
	private static class ReverseBiIterator KEY_GENERIC_TYPE implements BI_ITERATOR KEY_GENERIC_TYPE {
		BI_ITERATOR KEY_GENERIC_TYPE it;
		
		ReverseBiIterator(BI_ITERATOR KEY_GENERIC_TYPE it) {
			this.it = it;
		}
		
		@Override
		public KEY_TYPE NEXT() { return it.PREVIOUS(); }
		@Override
		public boolean hasNext() { return it.hasPrevious(); }
		@Override
		public boolean hasPrevious() { return it.hasNext(); }
		@Override
		public KEY_TYPE PREVIOUS() { return it.NEXT(); }
		@Override
		public void remove() { it.remove(); }
	}

	private static class ReverseListIterator KEY_GENERIC_TYPE implements LIST_ITERATOR KEY_GENERIC_TYPE {
		LIST_ITERATOR KEY_GENERIC_TYPE it;
		
		ReverseListIterator(LIST_ITERATOR KEY_GENERIC_TYPE it) {
			this.it = it;
		}
	
		@Override
		public KEY_TYPE NEXT() { return it.PREVIOUS(); }
		@Override
		public boolean hasNext() { return it.hasPrevious(); }
		@Override
		public boolean hasPrevious() { return it.hasNext(); }
		@Override
		public KEY_TYPE PREVIOUS() { return it.NEXT(); }
		@Override
		public void remove() { it.remove(); }
		@Override
		public int nextIndex() { return it.previousIndex(); }
		@Override
		public int previousIndex() { return it.nextIndex(); }
		@Override
		public void set(KEY_TYPE e) { it.set(e); }
		@Override
		public void add(KEY_TYPE e) { it.add(e); }
	}
	
	private static class UnmodifiableListIterator KEY_GENERIC_TYPE implements LIST_ITERATOR KEY_GENERIC_TYPE
	{
		LIST_ITERATOR KEY_GENERIC_TYPE iter;
	
		UnmodifiableListIterator(LIST_ITERATOR KEY_GENERIC_TYPE iter) {
			this.iter = iter;
		}
		
		@Override
		public boolean hasNext() {
			return iter.hasNext();
		}
		
		@Override
		public boolean hasPrevious() {
			return iter.hasPrevious();
		}
		
		@Override
		public int nextIndex() {
			return iter.nextIndex();
		}
		
		@Override
		public int previousIndex() {
			return iter.previousIndex();
		}
		
		@Override
		public void remove() { throw new UnsupportedOperationException(); }
		
		@Override
		public KEY_TYPE PREVIOUS() {
			return iter.PREVIOUS();
		}
		
		@Override
		public KEY_TYPE NEXT() {
			return iter.NEXT();
		}

		@Override
		public void set(KEY_TYPE e) { throw new UnsupportedOperationException(); }
		
		@Override
		public void add(KEY_TYPE e) { throw new UnsupportedOperationException(); }
	}
	
	private static class UnmodifiableBiIterator KEY_GENERIC_TYPE implements BI_ITERATOR KEY_GENERIC_TYPE
	{
		BI_ITERATOR KEY_GENERIC_TYPE iter;
		
		UnmodifiableBiIterator(BI_ITERATOR KEY_GENERIC_TYPE iter) {
			this.iter = iter;
		}
		
		@Override
		public KEY_TYPE NEXT() {
			return iter.NEXT();
		}
		
		@Override
		public boolean hasNext() {
			return iter.hasNext();
		}
		
		@Override
		public boolean hasPrevious() {
			return iter.hasPrevious();
		}
		
		@Override
		public KEY_TYPE PREVIOUS() {
			return iter.PREVIOUS();
		}
	}
	
	private static class UnmodifiableIterator KEY_GENERIC_TYPE implements ITERATOR KEY_GENERIC_TYPE
	{
		ITERATOR KEY_GENERIC_TYPE iterator;
	
		UnmodifiableIterator(ITERATOR KEY_GENERIC_TYPE iterator) {
			this.iterator = iterator;
		}
		
		@Override
		public boolean hasNext() {
			return iterator.hasNext();
		}
		
		@Override
		public KEY_TYPE NEXT() {
			return iterator.NEXT();
		}
	}

	private static class EmptyIterator KEY_GENERIC_TYPE implements LIST_ITERATOR KEY_GENERIC_TYPE
	{
		@Override
		public boolean hasNext() {
			return false;
		}
	
		@Override
		public KEY_TYPE NEXT() {
			return EMPTY_KEY_VALUE;
		}

		@Override
		public boolean hasPrevious() {
			return false;
		}
		
		@Override
		public KEY_TYPE PREVIOUS() {
			return EMPTY_KEY_VALUE;
		}
		
		@Override
		public int nextIndex() {
			return 0;
		}
		
		@Override
		public int previousIndex() {
			return 0;
		}
		
		@Override
		public void remove() { throw new UnsupportedOperationException(); }

		@Override
		public void set(KEY_TYPE e) { throw new UnsupportedOperationException(); }

		@Override
		public void add(KEY_TYPE e) { throw new UnsupportedOperationException(); }
	}
	
	private static class ArrayIterator KEY_GENERIC_TYPE implements ITERATOR KEY_GENERIC_TYPE
	{
		KEY_TYPE[] a;
		int from;
		int to;
		
		ArrayIterator(KEY_TYPE[] a, int from, int to) {
			this.a = a;
			this.from = from;
			this.to = to;
		}
		
		@Override
		public boolean hasNext() {
			return from < to;
		}
		
		@Override
		public KEY_TYPE NEXT() {
			return a[from++];
		}
		
		@Override
		public int skip(int amount) {
			if(amount < 0) throw new IllegalStateException("Negative Numbers are not allowed");
			int left = Math.min(amount, to - from);
			from += left;
			return amount - left;
		}
	}
}